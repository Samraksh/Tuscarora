<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tuscarora Framework API documentation: PWI::Framework_I Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Samraksh-logo-verysmall"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tuscarora Framework API documentation
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
   <div id="projectbrief">A framework for developing and depoloying multiple networking patterns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_p_w_i.html">PWI</a></li><li class="navelem"><a class="el" href="class_p_w_i_1_1_framework___i.html">Framework_I</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_p_w_i_1_1_framework___i-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PWI::Framework_I Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines the generic interations between the Pattern and the Framework.  
 <a href="class_p_w_i_1_1_framework___i.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_framework___i_8h_source.html">Framework_I.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe350ffa7efc7fe687215e980e6d1d3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#abe350ffa7efc7fe687215e980e6d1d3c">SendData</a> (PatternId_t pid, NodeId_t destArray[MAX_DEST], uint16_t noOfDest, <a class="el" href="class_core_1_1_message_t.html">FMessage_t</a> &amp;msg, uint16_t nonce, bool noDestAck=false)=0</td></tr>
<tr class="memdesc:abe350ffa7efc7fe687215e980e6d1d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message provided as parameter to the set of neighbors indicated by destArray.  <a href="#abe350ffa7efc7fe687215e980e6d1d3c">More...</a><br /></td></tr>
<tr class="separator:abe350ffa7efc7fe687215e980e6d1d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5d220f3d4b28c8f9961ccbc4db4498"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#a1f5d220f3d4b28c8f9961ccbc4db4498">BroadcastData</a> (PatternId_t pid, <a class="el" href="class_core_1_1_message_t.html">FMessage_t</a> &amp;msg, WaveformId_t wid, uint16_t nonce)=0</td></tr>
<tr class="memdesc:a1f5d220f3d4b28c8f9961ccbc4db4498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the data provided as parameter to all the destinations provided as an unaddressed broadcast message on a given waveform.  <a href="#a1f5d220f3d4b28c8f9961ccbc4db4498">More...</a><br /></td></tr>
<tr class="separator:a1f5d220f3d4b28c8f9961ccbc4db4498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f5e981436d5ffa471fb5631463b85d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#ad6f5e981436d5ffa471fb5631463b85d">ReplacePayloadRequest</a> (PatternId_t patternId, MessageId_t msgId, void *payload, uint16_t sizeOfPayload)=0</td></tr>
<tr class="memdesc:ad6f5e981436d5ffa471fb5631463b85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the payload of a packet already sent to the framework. The previous payload will be discarded and destroyed.  <a href="#ad6f5e981436d5ffa471fb5631463b85d">More...</a><br /></td></tr>
<tr class="separator:ad6f5e981436d5ffa471fb5631463b85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9918aa788afc67dab960be0d3c8b0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#a3a9918aa788afc67dab960be0d3c8b0e">NewPatternInstanceRequest</a> (<a class="el" href="namespace_core_1_1_naming.html#ab40d44ea919ec3e3c8cc05576ba6d610">PatternTypeE</a> ptype, char uniqueName[128]=NULL)=0</td></tr>
<tr class="memdesc:a3a9918aa788afc67dab960be0d3c8b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a pattern ID, based on the pattern type and an optional unique string.  <a href="#a3a9918aa788afc67dab960be0d3c8b0e">More...</a><br /></td></tr>
<tr class="separator:a3a9918aa788afc67dab960be0d3c8b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e8a69e9b97597aee795170ea4d4518"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#a51e8a69e9b97597aee795170ea4d4518">RegisterPatternRequest</a> (PatternId_t patternId, <a class="el" href="namespace_core_1_1_naming.html#ab40d44ea919ec3e3c8cc05576ba6d610">PatternTypeE</a> type)=0</td></tr>
<tr class="memdesc:a51e8a69e9b97597aee795170ea4d4518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a pattern with the framework.  <a href="#a51e8a69e9b97597aee795170ea4d4518">More...</a><br /></td></tr>
<tr class="separator:a51e8a69e9b97597aee795170ea4d4518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8ff64049e3908e47ad92c5d8cd2485"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#aee8ff64049e3908e47ad92c5d8cd2485">AddDestinationRequest</a> (PatternId_t patternId, MessageId_t msgId, NodeId_t destArray[MAX_DEST], uint16_t noOfNbrs)=0</td></tr>
<tr class="memdesc:aee8ff64049e3908e47ad92c5d8cd2485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds more destinations to a message already handed over to the framework. If the original message was sent using BroadcastData method, this new request is ignored.  <a href="#aee8ff64049e3908e47ad92c5d8cd2485">More...</a><br /></td></tr>
<tr class="separator:aee8ff64049e3908e47ad92c5d8cd2485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018a8d6a757ff5925f514c44e21d21d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#a018a8d6a757ff5925f514c44e21d21d1">CancelDataRequest</a> (PatternId_t patternId, MessageId_t msgId, NodeId_t destArray[MAX_DEST], uint16_t noOfDest)=0</td></tr>
<tr class="memdesc:a018a8d6a757ff5925f514c44e21d21d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels the sending of a message to one or more destinations of a message previously handed over to the framework.  <a href="#a018a8d6a757ff5925f514c44e21d21d1">More...</a><br /></td></tr>
<tr class="separator:a018a8d6a757ff5925f514c44e21d21d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e0bc143aa0009aec23dbe3c4ba26db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#a06e0bc143aa0009aec23dbe3c4ba26db">DataStatusRequest</a> (PatternId_t patternId, MessageId_t msgId)=0</td></tr>
<tr class="memdesc:a06e0bc143aa0009aec23dbe3c4ba26db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the status of a data message sent to the framework.  <a href="#a06e0bc143aa0009aec23dbe3c4ba26db">More...</a><br /></td></tr>
<tr class="separator:a06e0bc143aa0009aec23dbe3c4ba26db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af785062dc2e35cf4e7e0b83d90b6a861"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#af785062dc2e35cf4e7e0b83d90b6a861">SelectDataNotificationRequest</a> (PatternId_t patternId, uint8_t notifierMask)=0</td></tr>
<tr class="memdesc:af785062dc2e35cf4e7e0b83d90b6a861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets the Pattern Select which type of Data Notification Updates the Pattern wants to recieve.  <a href="#af785062dc2e35cf4e7e0b83d90b6a861">More...</a><br /></td></tr>
<tr class="separator:af785062dc2e35cf4e7e0b83d90b6a861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e4ba232772b54f21590ee01f0d46e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#a21e4ba232772b54f21590ee01f0d46e9">SetLinkThresholdRequest</a> (PatternId_t patternId, <a class="el" href="struct_core_1_1_link_metrics.html">LinkMetrics</a> threshold)=0</td></tr>
<tr class="memdesc:a21e4ba232772b54f21590ee01f0d46e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the link metric threshold to qualify as pattern neighbors.  <a href="#a21e4ba232772b54f21590ee01f0d46e9">More...</a><br /></td></tr>
<tr class="separator:a21e4ba232772b54f21590ee01f0d46e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0193172e5b9d95ac97183979a0a32a0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#a0193172e5b9d95ac97183979a0a32a0d">FrameworkAttributesRequest</a> (PatternId_t patternId)=0</td></tr>
<tr class="memdesc:a0193172e5b9d95ac97183979a0a32a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the attributes of the framework.  <a href="#a0193172e5b9d95ac97183979a0a32a0d">More...</a><br /></td></tr>
<tr class="separator:a0193172e5b9d95ac97183979a0a32a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb057c8987930daade5b990eed829d6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#abb057c8987930daade5b990eed829d6e">SelectLinkComparatorRequest</a> (PatternId_t patternId, <a class="el" href="namespace_p_w_i_1_1_neighborhood.html#a54f3d64f52739fa54193660451fd8a6f">LinkComparatorTypeE</a> lcType)=0</td></tr>
<tr class="memdesc:abb057c8987930daade5b990eed829d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the link comparator to use while comparing link qualities. Methods lets patterns to specify a link comparator from a list of existing library of comparators.  <a href="#abb057c8987930daade5b990eed829d6e">More...</a><br /></td></tr>
<tr class="separator:abb057c8987930daade5b990eed829d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16270cb3574bf7a2ef9a63144d9a2f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab16270cb3574bf7a2ef9a63144d9a2f2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_w_i_1_1_framework___i.html#ab16270cb3574bf7a2ef9a63144d9a2f2">~Framework_I</a> ()</td></tr>
<tr class="memdesc:ab16270cb3574bf7a2ef9a63144d9a2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:ab16270cb3574bf7a2ef9a63144d9a2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the generic interations between the Pattern and the Framework. </p>
<p>Interface class that defines a asynchornous message passing interface for interactions between the Pattern and the framework. A pattern may either be built as part of same process or as seperate process on the same node. When the pattern and the framework are running as two seperate processes, a shim-layer should be implementation that will translate the calls between the two processes.</p>
<p>The interactions in general consist of a command/request orginating from the Pattern to the framework and the framework responding to the commands using an Event response. There are 12 Commands that the pattern can issue to framework and 5 types of Events that the framework sends to the pattern. A command is a message in a specific format (based on a the command being invoked) sent from the pattern to the framework. Event is a message in a specific format sent from the framework to the pattern. While Commands and Events are messages, they are invoked using function syntax, just like invoking and providing functions. To send a command to the framework, a pattern uses a FRAMEWORK reference provided by the shim layer and to handle a event from the framework a pattern implements 4 methods one for each type of event. The shim layer takes care of invoking the correct method when the corresponding event message arrives.</p>
<p>The 4 event types are:</p><ol type="1">
<li>Control Response Event (PTN_ControlResponseEvent_t): This is dispatched in response to one of the *Request message, with an appropriate response type, response status (sucuss/failure), any additional data and its size.</li>
<li>Received Message Event (PTN_RcvMessageEvent_t) : This event is dispatched whenever a message is received for the pattern, with the message as the parameter</li>
<li>Data Notification Event (PTN_DatNotificationEvent_t): This is dispatched to convey the status of the SendData and BroadcastData calls. The event provides the cummulative status of a message. Each notification contains an array called `statusType' that specifies the status type corresponding to each destination and another boolen array called the `statusValue' that specifies if that operation was a success or failure. For each destination, the statuss type progress in the following sequence PDN_FW_RECV (framework received the packet), PDN_WF_RECV (waveform received the packet), PDN_WF_SENT (waveform sent the messsage out) and finally PDN_DST_RECV (destination received the message). The sequence stops at PDN_WF_SENT for messages sent using BroadcastData api, for which destination received notification is not supported. Also if the status type has progressed to the next in sequence, the previous type is implicitly successfull. For example, for a given destination the status type is 'PDN_WF_SENT', then it also means that PDN_FW_RECV and PDN_WF_RECV are true.</li>
<li>Neighbor Update Event (PTN_NeighborUpdateEvent_t): This event is dispatched to provide updates about the status of the nodes neighborhood. A neighbor update can either be about a new neighbor, a dead neighor or change in the quality of an existing neighbor. </li>
</ol>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aee8ff64049e3908e47ad92c5d8cd2485"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::AddDestinationRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageId_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeId_t&#160;</td>
          <td class="paramname"><em>destArray</em>[MAX_DEST], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>noOfNbrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds more destinations to a message already handed over to the framework. If the original message was sent using BroadcastData method, this new request is ignored. </p>
<p>Adds destinations to a message already sent to the framework. If the new destinations specifed using is destArray parameter is split across two or more waveforms, it is possible that the request can succeed for some of the new destinations and can fail for others. A Control Response Event will be generated by the framework with the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Pattern's instance ID. </td></tr>
    <tr><td class="paramname">msgId</td><td>Unique message ID. </td></tr>
    <tr><td class="paramname">destArray</td><td>Array of destinations to be added. </td></tr>
    <tr><td class="paramname">noOfNbrs</td><td>Number of new destinations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f5d220f3d4b28c8f9961ccbc4db4498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::BroadcastData </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_core_1_1_message_t.html">FMessage_t</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WaveformId_t&#160;</td>
          <td class="paramname"><em>wid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the data provided as parameter to all the destinations provided as an unaddressed broadcast message on a given waveform. </p>
<p><b>Data Notifications:</b> Framework returns one or more data notification events corresponding to each message sent. Notification for broadcast are returned in the index `0' of the `statusType' and `statusValue' arrays. BroadcastData follows the same sequence statys progressions, except it stops at PDN_WF_SENT.</p>
<p><b>Nonce:</b> Nonce is an unsigned integer that the pattern uses to identify the message, before the framework can return a message Id. Framework uses the nonce in the data notification and also returns a Message ID generated by the framework for the message. The nonce need not be unique for every message, but must be different for consequent messages. If two messages have the same once, then the framework assumes that the data notificaiton it sent to the pattern for the previous message is lost and hence the pattern is resending the same message with the same nonce.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Id of the pattern sending the message. </td></tr>
    <tr><td class="paramname">msg</td><td>Reference of the message to be send out. Tuscarora uses `handover' semantics for parameters passed as referece. That is the Pattern SHOULD NOT deallocate the message that is sent out. The shim layer will deallocate the message once it has been sent out. </td></tr>
    <tr><td class="paramname">wid</td><td><a class="el" href="namespace_waveform.html" title="Waveform Interface namespace. ">Waveform</a> ID of the waveform on which the broadcast should be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="a018a8d6a757ff5925f514c44e21d21d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::CancelDataRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageId_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeId_t&#160;</td>
          <td class="paramname"><em>destArray</em>[MAX_DEST], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>noOfDest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels the sending of a message to one or more destinations of a message previously handed over to the framework. </p>
<p>Cancels the sending of a message previously handed over to the framework. If no destination is specified or if the original message was sent using BroadcastData method, entire message is cancelled and destroyed. Otherwise sending is cancelled only to the desitnations specified in the destArray parameter. A Control Response Event is generated with the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Pattern's instance ID. </td></tr>
    <tr><td class="paramname">msgId</td><td>Unique message ID. </td></tr>
    <tr><td class="paramname">destArray</td><td>Array of destinations that need to be cancelled </td></tr>
    <tr><td class="paramname">noOfDest</td><td>Number of destinations to be cancelled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="a06e0bc143aa0009aec23dbe3c4ba26db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::DataStatusRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageId_t&#160;</td>
          <td class="paramname"><em>msgId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the status of a data message sent to the framework. </p>
<p>If for any reason a pattern has ambiguity about the status of a message that was sent to the framework, the pattern can use this method to request the status of the message. The framework will generate a Data Notification Event in response to this command, with the cummulative status of the message till that point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Pattern's instance ID. </td></tr>
    <tr><td class="paramname">msgId</td><td>ID of the message for which status is being requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a0193172e5b9d95ac97183979a0a32a0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::FrameworkAttributesRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the attributes of the framework. </p>
<p>The method is used to know the current attributes of the framework. The addritbutes are defined in the <a class="el" href="struct_p_w_i_1_1_framework_attributes.html" title="Describtes the attributes of the framework. ">FrameworkAttributes</a> struct. A pattern should first querry this method to find out the attributes of the framework before starting messaging. Critical information such as Max packet size, number of waveforms in the system, their IDs, etc. are returned through the <a class="el" href="struct_p_w_i_1_1_framework_attributes.html" title="Describtes the attributes of the framework. ">FrameworkAttributes</a> struct. A Control Response Event is generated in response to this command, with the <a class="el" href="struct_p_w_i_1_1_framework_attributes.html" title="Describtes the attributes of the framework. ">FrameworkAttributes</a> copied into the data section of the event. It is possible for the framework to generate a Control Response Event with the type set to `PTN_AttributeResponse', even without a pattern requesting it, if the framework attributes changes while a pattern is active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Pattern's instance ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a9918aa788afc67dab960be0d3c8b0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::NewPatternInstanceRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_core_1_1_naming.html#ab40d44ea919ec3e3c8cc05576ba6d610">PatternTypeE</a>&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uniqueName</em>[128] = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a pattern ID, based on the pattern type and an optional unique string. </p>
<p>The method is used to get a unique pattern ID for each pattern using the framework. The ID itself is generated by a Pattern Name Service. The framework acts as an pass through for this service. The ID is return through a Control Response Event. The uniqueName parameter can be used for fail-safe reasons. For example, if a pattern which was running crashes and reboot, it could get the ID for the previous instance by using the same uniqueName of the previous instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptype</td><td>Pattern type. </td></tr>
    <tr><td class="paramname">uniqueName</td><td>An optional parameter using which a pattern can identify itself to the framework. The Pattern Name Service will rememeber the string the pattern provides and will generate the same ID, if both the Pattern type and the uniqueName string match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="a51e8a69e9b97597aee795170ea4d4518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::RegisterPatternRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_core_1_1_naming.html#ab40d44ea919ec3e3c8cc05576ba6d610">PatternTypeE</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a pattern with the framework. </p>
<p><a class="el" href="namespace_patterns.html" title="Patern Writers Interface definition and types. ">Patterns</a> can use this method to register with the framework. A pattern will need to register first to be able to access the services of the framework. A Control Response Event will be generate to notify the pattern of the result of the registration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Unique ID of the Pattern </td></tr>
    <tr><td class="paramname">type</td><td>Pattern type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6f5e981436d5ffa471fb5631463b85d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::ReplacePayloadRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageId_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sizeOfPayload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the payload of a packet already sent to the framework. The previous payload will be discarded and destroyed. </p>
<p>Replaces the payload of a packet already sent to the framework. The previous payload will be discarded and destroyed. In response to this command one or more Control Response Event(s) may be generated by the framework. If the message has already been sent to the waveform, but not sent out by the waveform, the framework will issue commands to the waveform to replace the payload, however the waveform may return a failure. Hence, if the original message was sent to more than one destination, it is possible that this operation can fail for some destination and can succeed for others.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Id of the pattern sending the message. </td></tr>
    <tr><td class="paramname">msgId</td><td>ID of the message in which the payload should be replaced </td></tr>
    <tr><td class="paramname">payload</td><td>Pointer to new payload. </td></tr>
    <tr><td class="paramname">sizeOfPayload</td><td>Size of the new payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="af785062dc2e35cf4e7e0b83d90b6a861"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::SelectDataNotificationRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>notifierMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lets the Pattern Select which type of Data Notification Updates the Pattern wants to recieve. </p>
<p>This methods lets the pattern to customize data notifications that it wishes to receive. The customization is achived by specifying the mask of the data status types that pattern is interested in receiving. While this could decrease the number and frequency of notifications the pattern receives, the framework cannot completely eliminate the status types that the pattern is not interested in since the data notification is an cummulative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Pattern's instance ID. </td></tr>
    <tr><td class="paramname">notifierMask</td><td>Mask of the notifications that are requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="abb057c8987930daade5b990eed829d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::SelectLinkComparatorRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_p_w_i_1_1_neighborhood.html#a54f3d64f52739fa54193660451fd8a6f">LinkComparatorTypeE</a>&#160;</td>
          <td class="paramname"><em>lcType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects the link comparator to use while comparing link qualities. Methods lets patterns to specify a link comparator from a list of existing library of comparators. </p>
<p>This method lets a pattern to customize the comparison of the link metrics between two links. While there are 5 standard link metrics, how to select one link as better than another can be customized using this method, by selecting one of the many pre-approved comparators. Please see documentation for `LinkComparatorTypeE' for available comparators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Pattern's instance ID. </td></tr>
    <tr><td class="paramname">lcType</td><td>Type of the link comparator. Enum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a class="anchor" id="abe350ffa7efc7fe687215e980e6d1d3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::SendData </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeId_t&#160;</td>
          <td class="paramname"><em>destArray</em>[MAX_DEST], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>noOfDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_core_1_1_message_t.html">FMessage_t</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nonce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noDestAck</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends message provided as parameter to the set of neighbors indicated by destArray. </p>
<p>This is the primary method a pattern uses to request that a message be transmitted to its neighbors. The first two parameters are self-explanatory. The third parameter is an array of one or more neighbors to which the message is to be sent, each of which are identified by the neighborâ€™s waveform address. The Framework may use the given MessageId to cancel or replace the payload in future (via calls to the next two methods). The parameter noDestAck specifies whether a notification is requested when this message has reached its intended destination(s). A true value for this field means the Framework does not need notifications for this message. If data notifications/acknowledgements are not supported by the waveform, this parameter may be ignored.</p>
<p><b>Data Notifications:</b> Framework returns one or more data notification events corresponding to each message sent. The Data Notifications are cummulative in nature. Each notification contains an array called `statusType' that specifies the status type corresponding to each destination and another boolen array called the `statusValue' that specifies if that operation was a success or failure.</p>
<p><b>Nonce:</b> Nonce is an unsigned integer that the pattern uses to identify the message, before the framework can return a message Id. Framework uses the nonce in the data notification and also returns a Message ID generated by the framework for the message. The nonce need not be unique for every message, but must be different for consequent messages. If two messages have the same once, then the framework assumes that the data notificaiton it sent to the pattern for the previous message is lost and hence the pattern is resending the same message with the same nonce.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>Id of the pattern sending the message. </td></tr>
    <tr><td class="paramname">destArray</td><td>List of destinations. </td></tr>
    <tr><td class="paramname">noOfDest</td><td>Number of destinations specified in the destination array. </td></tr>
    <tr><td class="paramname">msg</td><td>Reference of the message to be send out. Tuscarora uses `handover' semantics for parameters passed as referece. That is the Pattern SHOULD NOT deallocate the message that is sent out. The shim layer will deallocate the message once it has been sent out. </td></tr>
    <tr><td class="paramname">nonce</td><td>An unsigned integer specified by the pattern to differentiate this message from previous message. It is used for error recovery between the pattern and the framework. </td></tr>
    <tr><td class="paramname">noDestAck</td><td>Indicates if the pattern is not requesting destination acknowledgement for this message. A true value means no destination ack is requested. Default value is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a21e4ba232772b54f21590ee01f0d46e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PWI::Framework_I::SetLinkThresholdRequest </td>
          <td>(</td>
          <td class="paramtype">PatternId_t&#160;</td>
          <td class="paramname"><em>patternId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_core_1_1_link_metrics.html">LinkMetrics</a>&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the link metric threshold to qualify as pattern neighbors. </p>
<p>This method lets a Pattern customize its neighbor and the neighborhood updates. A pattern can specify the minimum metric that a link should meet to qualify as its neighbor. This simplifies neighbor maintanence and look up.Also, neighborhood updates will be sent to patterns only about neighbors who meet this threshold, hence the number of Neighbor Update Events sent to the pattern will decrease. If a pattern does not set this threshold, all neighbors know to the framework will be published to the pattern. A Control Response Event is generated in response to this command to indicate the status of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternId</td><td>Pattern's instance ID. </td></tr>
    <tr><td class="paramname">threshold</td><td>Link metric threshold to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>TuscaroraFW/Include/Interfaces/PWI/<a class="el" href="_framework___i_8h_source.html">Framework_I.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 2 2015 17:56:02 for Tuscarora Framework API documentation by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
